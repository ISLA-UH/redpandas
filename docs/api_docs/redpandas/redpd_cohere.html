<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redpandas.redpd_cohere API documentation</title>
<meta name="description" content="This module contains functions to calculate coherence." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redpandas.redpd_cohere</code></h1>
</header>
<section id="section-intro">
This module contains functions to calculate coherence.
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains functions to calculate coherence.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from scipy import signal
from libquantum import utils
import redpandas.redpd_plot.coherence as rpd_plt


def coherence_numpy(sig_in: np.ndarray,
                    sig_in_ref: np.ndarray,
                    sig_sample_rate_hz: int,
                    sig_ref_sample_rate_hz: int,
                    window_seconds: float = 2.,
                    window_overlap_fractional: float = 0.5,
                    frequency_ref_hz: float = 40.,
                    frequency_min_hz: float = 1.,
                    frequency_max_hz: float = 320.,
                    sig_calib: float = 1.,
                    sig_ref_calib: float = 1.):
    &#34;&#34;&#34;
    Find coherence between a signal and a reference signal, plot results

    :param sig_in: signal
    :param sig_in_ref: reference signal
    :param sig_sample_rate_hz: sample rate of signal in Hz
    :param sig_ref_sample_rate_hz: sample rate of reference signal in Hz
    :param window_seconds: seconds duration of window. Default is 2.0
    :param window_overlap_fractional: number of points to overlap between segments in window. Default is 0.5
    :param frequency_ref_hz: reference frequency in Hz. Default is 40.0
    :param frequency_min_hz: minimum frequency to plot in Hz (x min limit). Default is 1.0
    :param frequency_max_hz: maximum frequency to plot in Hz (x max limit). Default is 320.
    :param sig_calib: calibration of signal. Default is 1.0
    :param sig_ref_calib: calibration of reference signal. Default is 1.0
    :return: plots
    &#34;&#34;&#34;

    # Stated with WACT IMS ref code, increased consistency.
    # Core computation is standard scipy.signal.

    # Compute PSDs and response - /4 calib divider removed
    sig_ref = np.copy(sig_in_ref) * sig_ref_calib
    sig = np.copy(sig_in) * sig_calib

    window_points = int(window_seconds*sig_sample_rate_hz)
    window_overlap_points = int(window_overlap_fractional*window_points)

    # Compute PSDs for each and coherence between the two
    f, pxx_ref = signal.welch(x=sig_ref,
                              fs=sig_ref_sample_rate_hz,
                              nperseg=window_points,
                              noverlap=window_overlap_points)
    f, pxx_sig = signal.welch(x=sig,
                              fs=sig_sample_rate_hz,
                              nperseg=window_points,
                              noverlap=window_overlap_points)

    # dB, absolute -  add EPSILON
    psd_ref_bits = 0.5 * np.log2(abs(pxx_ref))
    psd_sig_bits = 0.5 * np.log2(abs(pxx_sig))

    # Compute cross-power spectral density with ref sample rate
    # Original code had no overlap - fixed

    f, Pxy = signal.csd(x=sig,
                        y=sig_ref,
                        fs=sig_ref_sample_rate_hz,
                        nperseg=window_points,
                        noverlap=window_overlap_points)
    cross_spectrum_bits = 0.5 * np.log2(abs(Pxy))

    # Coherence, same as from PSD
    f, Cxy = signal.coherence(x=sig,
                              y=sig_ref,
                              fs=sig_ref_sample_rate_hz,
                              nperseg=window_points,
                              noverlap=window_overlap_points)

    # Compute response assuming incoherent comp in ref.
    # Ref sensor response already removed
    H_x = pxx_sig / Pxy

    # compute magnitude and phase in deg
    mag = np.abs(H_x)
    ph = np.unwrap(180 / np.pi * np.angle(H_x))

    # get new mag and phase values at frequency closest to ref frequency
    frequency_ref_index = np.argmin(np.abs(f - frequency_ref_hz))
    frequency_coherence_max_index = np.argmax(Cxy)

    calmag = mag[frequency_ref_index]
    calph = ph[frequency_ref_index]
    calcoh = Cxy[frequency_ref_index]
    maxcoh_f = f[frequency_coherence_max_index]
    maxcoh = Cxy[frequency_coherence_max_index]

    calflab = &#39;%s, %.2f Hz&#39; % (&#39;Ref frequency&#39;, frequency_ref_hz)
    calmaglab = &#39;Mag=%.2f&#39; % calmag
    calphlab = &#39;Phase=%.2f&#39; % calph
    calcohlab = &#39;Coherence=%.2f&#39; % calcoh

    print(calflab)
    print(calmaglab)
    print(calphlab)
    print(calcohlab)
    print(&#39;Max coherence frequency, level:&#39;)
    print(maxcoh_f, maxcoh)

    rpd_plt.plot_psd_coh(psd_sig=psd_sig_bits, psd_ref=psd_ref_bits,
                         coherence_sig_ref=Cxy,
                         f_hz=f,
                         f_min_hz=frequency_min_hz,
                         f_max_hz=frequency_max_hz,
                         f_scale=&#39;linear&#39;)

    rpd_plt.plot_psd_coh(psd_sig=cross_spectrum_bits, psd_ref=psd_ref_bits,
                         coherence_sig_ref=Cxy,
                         f_hz=f,
                         f_min_hz=frequency_min_hz,
                         f_max_hz=frequency_max_hz,
                         f_scale=&#39;linear&#39;,
                         sig_label=&#39;Cross spectrum&#39;)

    rpd_plt.plot_response_scatter(h_magnitude=mag,
                                  h_phase_deg=ph,
                                  color_guide=Cxy,
                                  f_hz=f,
                                  f_min_hz=frequency_min_hz,
                                  f_max_hz=frequency_max_hz,
                                  f_scale=&#39;linear&#39;)


def coherence_re_ref_pandas(df: pd.DataFrame,
                            ref_id: str,
                            sig_id_label: str,
                            sig_wf_label: str,
                            sig_sample_rate_label: str,
                            fs_fractional_tolerance: float = 0.02,
                            window_seconds: float = 2.,
                            window_overlap_fractional: float = 0.5,
                            frequency_ref_hz: float = 40.,
                            frequency_min_hz: float = 1,
                            frequency_max_hz: float = 320.,
                            sig_calib: float = 1.,
                            sig_ref_calib: float = 1.,
                            export_option: str = &#39;max_coherence&#39;,
                            plot_response: bool = False,
                            new_column_label_cohere_frequency: str = &#39;coherence_frequency&#39;,
                            new_column_label_cohere_value: str = &#39;coherence_value&#39;,
                            new_column_label_cohere_response_magnitude_bits: str = &#39;coherence_response_magnitude_bits&#39;,
                            new_column_label_cohere_response_phase_degrees: str = &#39;coherence_response_phase_degrees&#39;
                            ) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Find coherence between signals stored in dataframe, plot results

    :param df: input pandas DataFrame
    :param ref_id: name of reference signal in sig_id_label column in df
    :param sig_id_label: string for column name with station ids in df
    :param sig_wf_label: string for column name with waveform data in df
    :param sig_sample_rate_label: string for column name with sample rate in Hz information in df
    :param fs_fractional_tolerance: difference in sample rate (in Hz) tolerated. Default is 0.02
    :param window_seconds: seconds duration of window. Default is 2.0
    :param window_overlap_fractional: number of points to overlap between segments in window. Default is 0.5
    :param frequency_ref_hz: reference frequency in Hz. Default is 40.0
    :param frequency_min_hz: minimum frequency to plot in Hz (x min limit). Default is 1.0
    :param frequency_max_hz: maximum frequency to plot in Hz (x max limit). Default is 320.
    :param sig_calib: calibration of signal. Default is 1.0
    :param sig_ref_calib: sample rate of reference signal in Hz
    :param export_option: &#39;max_coherence&#39; or &#39;ref_frequency&#39;. Default is &#39;max_coherenece&#39;
    :param plot_response: plot results. Default is False
    :param new_column_label_cohere_frequency: string for new column containing coherence frequency
    :param new_column_label_cohere_value: string for new column containing coherence values
    :param new_column_label_cohere_response_magnitude_bits: string for new column containing coherence response in bits
    :param new_column_label_cohere_response_phase_degrees: string for new column containing coherence phase in degrees
    :return: input pandas dataframe with new columns
    &#34;&#34;&#34;

    number_sig = len(df.index)
    print(&#34;Coherence, number of signals excluding reference:&#34;, number_sig-1)
    print(&#34;Reference station: &#34;, ref_id)
    # exit()

    # Is there a better way?
    m_list = df.index[df[sig_id_label] == ref_id]
    m = m_list[0]
    # print(&#34;m&#34;, m)
    if len(m_list) &gt; 1:
        raise Warning(&#34;More than one station meets the id spec. Picked first instance&#34;)

    # Initialize
    coherence_frequency = []
    coherence_value = []
    coherence_response_magnitude_bits = []
    coherence_response_phase_degrees = []

    if m is not None:
        print(&#34;Coherence Reference station &#34;, df[sig_id_label][m])
        sig_m = np.copy(df[sig_wf_label][m]) * sig_ref_calib

        for n in df.index:
            sample_rate_condition = np.abs(df[sig_sample_rate_label][m] - df[sig_sample_rate_label][n]) \
                                    &gt; fs_fractional_tolerance*df[sig_sample_rate_label][m]
            if sample_rate_condition:
                print(&#34;Sample rates out of tolerance&#34;)
                continue
            else:
                # Generalized sensor cross correlations, including unequal lengths
                sig_n = np.copy(df[sig_wf_label][n]) * sig_calib

            # Compute PSDs for each and coherence between the two
            window_points = int(window_seconds * df[sig_sample_rate_label][m])
            window_overlap_points = int(window_overlap_fractional*window_points)

            frequency_auto, auto_spectrum_sig = signal.welch(x=sig_n,
                                                             fs=df[sig_sample_rate_label][n],
                                                             nperseg=window_points,
                                                             noverlap=window_overlap_points)
            _, auto_spectrum_ref = signal.welch(x=sig_m,
                                                fs=df[sig_sample_rate_label][m],
                                                nperseg=window_points,
                                                noverlap=window_overlap_points)

            # Compute cross-power spectral density with ref sample rate
            frequency_cross, cross_spectrum = signal.csd(x=sig_n,
                                                         y=sig_m,
                                                         fs=df[sig_sample_rate_label][m],
                                                         nperseg=window_points,
                                                         noverlap=window_overlap_points)

            psd_ref_bits = 0.5 * utils.log2epsilon(abs(auto_spectrum_ref))
            psd_sig_bits = 0.5 * utils.log2epsilon(abs(auto_spectrum_sig))
            cross_spectrum_bits = 0.5 * utils.log2epsilon(abs(cross_spectrum))

            # Coherence, same as coherence from PSD
            frequency_coherence, coherence_welch = signal.coherence(x=sig_n,
                                                                    y=sig_m,
                                                                    fs=df[sig_sample_rate_label][m],
                                                                    nperseg=window_points,
                                                                    noverlap=window_overlap_points)

            # Compute response
            h_complex_response_sig = auto_spectrum_sig / cross_spectrum

            # Compute magnitude and phase in degrees
            magnitude_norm = np.abs(h_complex_response_sig)
            phase_degrees = np.unwrap(180 / np.pi * np.angle(h_complex_response_sig))

            # Assumes all the frequencies are the same - must verify
            frequency_ref_index = np.argmin(np.abs(frequency_coherence - frequency_ref_hz))
            frequency_coherence_max_index = np.argmax(coherence_welch)

            # New magnitude_norm and phase values at coherence frequency closest to ref frequency
            ref_frequency_hz = frequency_coherence[frequency_coherence_max_index]
            ref_frequency_coherence = coherence_welch[frequency_ref_index]
            ref_frequency_response_magnitude_bits = 0.5*utils.log2epsilon(magnitude_norm[frequency_ref_index])
            ref_frequency_response_phase_degrees = phase_degrees[frequency_ref_index]

            # Return max coherence values
            max_coherence_frequency_hz = frequency_coherence[frequency_coherence_max_index]
            max_coherence = np.max(coherence_welch)
            max_coherence_response_magnitude_bits = 0.5*utils.log2epsilon(magnitude_norm[frequency_coherence_max_index])
            max_coherence_response_phase_degrees = phase_degrees[frequency_coherence_max_index]

            if n == m:
                max_coherence_frequency_hz = np.nan

            if &#39;max_coherence&#39; == export_option:
                coherence_frequency.append(max_coherence_frequency_hz)
                coherence_value.append(max_coherence)
                coherence_response_magnitude_bits.append(max_coherence_response_magnitude_bits)
                coherence_response_phase_degrees.append(max_coherence_response_phase_degrees)
            if &#39;ref_frequency&#39; == export_option:
                coherence_frequency.append(ref_frequency_hz)
                coherence_value.append(ref_frequency_coherence)
                coherence_response_magnitude_bits.append(ref_frequency_response_magnitude_bits)
                coherence_response_phase_degrees.append(ref_frequency_response_phase_degrees)

            if plot_response:
                rpd_plt.plot_psd_coh(psd_sig=psd_sig_bits, psd_ref=psd_ref_bits,
                                     coherence_sig_ref=coherence_welch,
                                     f_hz=frequency_coherence,
                                     f_min_hz=frequency_min_hz,
                                     f_max_hz=frequency_max_hz,
                                     f_scale=&#39;linear&#39;)

                rpd_plt.plot_psd_coh(psd_sig=cross_spectrum_bits, psd_ref=psd_ref_bits,
                                     coherence_sig_ref=coherence_welch,
                                     f_hz=frequency_coherence,
                                     f_min_hz=frequency_min_hz,
                                     f_max_hz=frequency_max_hz,
                                     f_scale=&#39;linear&#39;,
                                     sig_label=&#39;Cross spectrum&#39;)

                rpd_plt.plot_response_scatter(h_magnitude=magnitude_norm,
                                              h_phase_deg=phase_degrees,
                                              color_guide=coherence_welch,
                                              f_hz=frequency_coherence,
                                              f_min_hz=frequency_min_hz,
                                              f_max_hz=frequency_max_hz,
                                              f_scale=&#39;linear&#39;)

        df[new_column_label_cohere_frequency] = coherence_frequency
        df[new_column_label_cohere_value] = coherence_value
        df[new_column_label_cohere_response_magnitude_bits] = coherence_response_magnitude_bits
        df[new_column_label_cohere_response_phase_degrees] = coherence_response_phase_degrees

    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redpandas.redpd_cohere.coherence_numpy"><code class="name flex">
<span>def <span class="ident">coherence_numpy</span></span>(<span>sig_in: numpy.ndarray, sig_in_ref: numpy.ndarray, sig_sample_rate_hz: int, sig_ref_sample_rate_hz: int, window_seconds: float = 2.0, window_overlap_fractional: float = 0.5, frequency_ref_hz: float = 40.0, frequency_min_hz: float = 1.0, frequency_max_hz: float = 320.0, sig_calib: float = 1.0, sig_ref_calib: float = 1.0)</span>
</code></dt>
<dd>
<div class="desc">Find coherence between a signal and a reference signal, plot results<br><br>:param sig_in: signal<br>:param sig_in_ref: reference signal<br>:param sig_sample_rate_hz: sample rate of signal in Hz<br>:param sig_ref_sample_rate_hz: sample rate of reference signal in Hz<br>:param window_seconds: seconds duration of window. Default is 2.0<br>:param window_overlap_fractional: number of points to overlap between segments in window. Default is 0.5<br>:param frequency_ref_hz: reference frequency in Hz. Default is 40.0<br>:param frequency_min_hz: minimum frequency to plot in Hz (x min limit). Default is 1.0<br>:param frequency_max_hz: maximum frequency to plot in Hz (x max limit). Default is 320.<br>:param sig_calib: calibration of signal. Default is 1.0<br>:param sig_ref_calib: calibration of reference signal. Default is 1.0<br>:return: plots</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coherence_numpy(sig_in: np.ndarray,
                    sig_in_ref: np.ndarray,
                    sig_sample_rate_hz: int,
                    sig_ref_sample_rate_hz: int,
                    window_seconds: float = 2.,
                    window_overlap_fractional: float = 0.5,
                    frequency_ref_hz: float = 40.,
                    frequency_min_hz: float = 1.,
                    frequency_max_hz: float = 320.,
                    sig_calib: float = 1.,
                    sig_ref_calib: float = 1.):
    &#34;&#34;&#34;
    Find coherence between a signal and a reference signal, plot results

    :param sig_in: signal
    :param sig_in_ref: reference signal
    :param sig_sample_rate_hz: sample rate of signal in Hz
    :param sig_ref_sample_rate_hz: sample rate of reference signal in Hz
    :param window_seconds: seconds duration of window. Default is 2.0
    :param window_overlap_fractional: number of points to overlap between segments in window. Default is 0.5
    :param frequency_ref_hz: reference frequency in Hz. Default is 40.0
    :param frequency_min_hz: minimum frequency to plot in Hz (x min limit). Default is 1.0
    :param frequency_max_hz: maximum frequency to plot in Hz (x max limit). Default is 320.
    :param sig_calib: calibration of signal. Default is 1.0
    :param sig_ref_calib: calibration of reference signal. Default is 1.0
    :return: plots
    &#34;&#34;&#34;

    # Stated with WACT IMS ref code, increased consistency.
    # Core computation is standard scipy.signal.

    # Compute PSDs and response - /4 calib divider removed
    sig_ref = np.copy(sig_in_ref) * sig_ref_calib
    sig = np.copy(sig_in) * sig_calib

    window_points = int(window_seconds*sig_sample_rate_hz)
    window_overlap_points = int(window_overlap_fractional*window_points)

    # Compute PSDs for each and coherence between the two
    f, pxx_ref = signal.welch(x=sig_ref,
                              fs=sig_ref_sample_rate_hz,
                              nperseg=window_points,
                              noverlap=window_overlap_points)
    f, pxx_sig = signal.welch(x=sig,
                              fs=sig_sample_rate_hz,
                              nperseg=window_points,
                              noverlap=window_overlap_points)

    # dB, absolute -  add EPSILON
    psd_ref_bits = 0.5 * np.log2(abs(pxx_ref))
    psd_sig_bits = 0.5 * np.log2(abs(pxx_sig))

    # Compute cross-power spectral density with ref sample rate
    # Original code had no overlap - fixed

    f, Pxy = signal.csd(x=sig,
                        y=sig_ref,
                        fs=sig_ref_sample_rate_hz,
                        nperseg=window_points,
                        noverlap=window_overlap_points)
    cross_spectrum_bits = 0.5 * np.log2(abs(Pxy))

    # Coherence, same as from PSD
    f, Cxy = signal.coherence(x=sig,
                              y=sig_ref,
                              fs=sig_ref_sample_rate_hz,
                              nperseg=window_points,
                              noverlap=window_overlap_points)

    # Compute response assuming incoherent comp in ref.
    # Ref sensor response already removed
    H_x = pxx_sig / Pxy

    # compute magnitude and phase in deg
    mag = np.abs(H_x)
    ph = np.unwrap(180 / np.pi * np.angle(H_x))

    # get new mag and phase values at frequency closest to ref frequency
    frequency_ref_index = np.argmin(np.abs(f - frequency_ref_hz))
    frequency_coherence_max_index = np.argmax(Cxy)

    calmag = mag[frequency_ref_index]
    calph = ph[frequency_ref_index]
    calcoh = Cxy[frequency_ref_index]
    maxcoh_f = f[frequency_coherence_max_index]
    maxcoh = Cxy[frequency_coherence_max_index]

    calflab = &#39;%s, %.2f Hz&#39; % (&#39;Ref frequency&#39;, frequency_ref_hz)
    calmaglab = &#39;Mag=%.2f&#39; % calmag
    calphlab = &#39;Phase=%.2f&#39; % calph
    calcohlab = &#39;Coherence=%.2f&#39; % calcoh

    print(calflab)
    print(calmaglab)
    print(calphlab)
    print(calcohlab)
    print(&#39;Max coherence frequency, level:&#39;)
    print(maxcoh_f, maxcoh)

    rpd_plt.plot_psd_coh(psd_sig=psd_sig_bits, psd_ref=psd_ref_bits,
                         coherence_sig_ref=Cxy,
                         f_hz=f,
                         f_min_hz=frequency_min_hz,
                         f_max_hz=frequency_max_hz,
                         f_scale=&#39;linear&#39;)

    rpd_plt.plot_psd_coh(psd_sig=cross_spectrum_bits, psd_ref=psd_ref_bits,
                         coherence_sig_ref=Cxy,
                         f_hz=f,
                         f_min_hz=frequency_min_hz,
                         f_max_hz=frequency_max_hz,
                         f_scale=&#39;linear&#39;,
                         sig_label=&#39;Cross spectrum&#39;)

    rpd_plt.plot_response_scatter(h_magnitude=mag,
                                  h_phase_deg=ph,
                                  color_guide=Cxy,
                                  f_hz=f,
                                  f_min_hz=frequency_min_hz,
                                  f_max_hz=frequency_max_hz,
                                  f_scale=&#39;linear&#39;)</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_cohere.coherence_re_ref_pandas"><code class="name flex">
<span>def <span class="ident">coherence_re_ref_pandas</span></span>(<span>df: pandas.core.frame.DataFrame, ref_id: str, sig_id_label: str, sig_wf_label: str, sig_sample_rate_label: str, fs_fractional_tolerance: float = 0.02, window_seconds: float = 2.0, window_overlap_fractional: float = 0.5, frequency_ref_hz: float = 40.0, frequency_min_hz: float = 1, frequency_max_hz: float = 320.0, sig_calib: float = 1.0, sig_ref_calib: float = 1.0, export_option: str = 'max_coherence', plot_response: bool = False, new_column_label_cohere_frequency: str = 'coherence_frequency', new_column_label_cohere_value: str = 'coherence_value', new_column_label_cohere_response_magnitude_bits: str = 'coherence_response_magnitude_bits', new_column_label_cohere_response_phase_degrees: str = 'coherence_response_phase_degrees') ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc">Find coherence between signals stored in dataframe, plot results<br><br>:param df: input pandas DataFrame<br>:param ref_id: name of reference signal in sig_id_label column in df<br>:param sig_id_label: string for column name with station ids in df<br>:param sig_wf_label: string for column name with waveform data in df<br>:param sig_sample_rate_label: string for column name with sample rate in Hz information in df<br>:param fs_fractional_tolerance: difference in sample rate (in Hz) tolerated. Default is 0.02<br>:param window_seconds: seconds duration of window. Default is 2.0<br>:param window_overlap_fractional: number of points to overlap between segments in window. Default is 0.5<br>:param frequency_ref_hz: reference frequency in Hz. Default is 40.0<br>:param frequency_min_hz: minimum frequency to plot in Hz (x min limit). Default is 1.0<br>:param frequency_max_hz: maximum frequency to plot in Hz (x max limit). Default is 320.<br>:param sig_calib: calibration of signal. Default is 1.0<br>:param sig_ref_calib: sample rate of reference signal in Hz<br>:param export_option: 'max_coherence' or 'ref_frequency'. Default is 'max_coherenece'<br>:param plot_response: plot results. Default is False<br>:param new_column_label_cohere_frequency: string for new column containing coherence frequency<br>:param new_column_label_cohere_value: string for new column containing coherence values<br>:param new_column_label_cohere_response_magnitude_bits: string for new column containing coherence response in bits<br>:param new_column_label_cohere_response_phase_degrees: string for new column containing coherence phase in degrees<br>:return: input pandas dataframe with new columns</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coherence_re_ref_pandas(df: pd.DataFrame,
                            ref_id: str,
                            sig_id_label: str,
                            sig_wf_label: str,
                            sig_sample_rate_label: str,
                            fs_fractional_tolerance: float = 0.02,
                            window_seconds: float = 2.,
                            window_overlap_fractional: float = 0.5,
                            frequency_ref_hz: float = 40.,
                            frequency_min_hz: float = 1,
                            frequency_max_hz: float = 320.,
                            sig_calib: float = 1.,
                            sig_ref_calib: float = 1.,
                            export_option: str = &#39;max_coherence&#39;,
                            plot_response: bool = False,
                            new_column_label_cohere_frequency: str = &#39;coherence_frequency&#39;,
                            new_column_label_cohere_value: str = &#39;coherence_value&#39;,
                            new_column_label_cohere_response_magnitude_bits: str = &#39;coherence_response_magnitude_bits&#39;,
                            new_column_label_cohere_response_phase_degrees: str = &#39;coherence_response_phase_degrees&#39;
                            ) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Find coherence between signals stored in dataframe, plot results

    :param df: input pandas DataFrame
    :param ref_id: name of reference signal in sig_id_label column in df
    :param sig_id_label: string for column name with station ids in df
    :param sig_wf_label: string for column name with waveform data in df
    :param sig_sample_rate_label: string for column name with sample rate in Hz information in df
    :param fs_fractional_tolerance: difference in sample rate (in Hz) tolerated. Default is 0.02
    :param window_seconds: seconds duration of window. Default is 2.0
    :param window_overlap_fractional: number of points to overlap between segments in window. Default is 0.5
    :param frequency_ref_hz: reference frequency in Hz. Default is 40.0
    :param frequency_min_hz: minimum frequency to plot in Hz (x min limit). Default is 1.0
    :param frequency_max_hz: maximum frequency to plot in Hz (x max limit). Default is 320.
    :param sig_calib: calibration of signal. Default is 1.0
    :param sig_ref_calib: sample rate of reference signal in Hz
    :param export_option: &#39;max_coherence&#39; or &#39;ref_frequency&#39;. Default is &#39;max_coherenece&#39;
    :param plot_response: plot results. Default is False
    :param new_column_label_cohere_frequency: string for new column containing coherence frequency
    :param new_column_label_cohere_value: string for new column containing coherence values
    :param new_column_label_cohere_response_magnitude_bits: string for new column containing coherence response in bits
    :param new_column_label_cohere_response_phase_degrees: string for new column containing coherence phase in degrees
    :return: input pandas dataframe with new columns
    &#34;&#34;&#34;

    number_sig = len(df.index)
    print(&#34;Coherence, number of signals excluding reference:&#34;, number_sig-1)
    print(&#34;Reference station: &#34;, ref_id)
    # exit()

    # Is there a better way?
    m_list = df.index[df[sig_id_label] == ref_id]
    m = m_list[0]
    # print(&#34;m&#34;, m)
    if len(m_list) &gt; 1:
        raise Warning(&#34;More than one station meets the id spec. Picked first instance&#34;)

    # Initialize
    coherence_frequency = []
    coherence_value = []
    coherence_response_magnitude_bits = []
    coherence_response_phase_degrees = []

    if m is not None:
        print(&#34;Coherence Reference station &#34;, df[sig_id_label][m])
        sig_m = np.copy(df[sig_wf_label][m]) * sig_ref_calib

        for n in df.index:
            sample_rate_condition = np.abs(df[sig_sample_rate_label][m] - df[sig_sample_rate_label][n]) \
                                    &gt; fs_fractional_tolerance*df[sig_sample_rate_label][m]
            if sample_rate_condition:
                print(&#34;Sample rates out of tolerance&#34;)
                continue
            else:
                # Generalized sensor cross correlations, including unequal lengths
                sig_n = np.copy(df[sig_wf_label][n]) * sig_calib

            # Compute PSDs for each and coherence between the two
            window_points = int(window_seconds * df[sig_sample_rate_label][m])
            window_overlap_points = int(window_overlap_fractional*window_points)

            frequency_auto, auto_spectrum_sig = signal.welch(x=sig_n,
                                                             fs=df[sig_sample_rate_label][n],
                                                             nperseg=window_points,
                                                             noverlap=window_overlap_points)
            _, auto_spectrum_ref = signal.welch(x=sig_m,
                                                fs=df[sig_sample_rate_label][m],
                                                nperseg=window_points,
                                                noverlap=window_overlap_points)

            # Compute cross-power spectral density with ref sample rate
            frequency_cross, cross_spectrum = signal.csd(x=sig_n,
                                                         y=sig_m,
                                                         fs=df[sig_sample_rate_label][m],
                                                         nperseg=window_points,
                                                         noverlap=window_overlap_points)

            psd_ref_bits = 0.5 * utils.log2epsilon(abs(auto_spectrum_ref))
            psd_sig_bits = 0.5 * utils.log2epsilon(abs(auto_spectrum_sig))
            cross_spectrum_bits = 0.5 * utils.log2epsilon(abs(cross_spectrum))

            # Coherence, same as coherence from PSD
            frequency_coherence, coherence_welch = signal.coherence(x=sig_n,
                                                                    y=sig_m,
                                                                    fs=df[sig_sample_rate_label][m],
                                                                    nperseg=window_points,
                                                                    noverlap=window_overlap_points)

            # Compute response
            h_complex_response_sig = auto_spectrum_sig / cross_spectrum

            # Compute magnitude and phase in degrees
            magnitude_norm = np.abs(h_complex_response_sig)
            phase_degrees = np.unwrap(180 / np.pi * np.angle(h_complex_response_sig))

            # Assumes all the frequencies are the same - must verify
            frequency_ref_index = np.argmin(np.abs(frequency_coherence - frequency_ref_hz))
            frequency_coherence_max_index = np.argmax(coherence_welch)

            # New magnitude_norm and phase values at coherence frequency closest to ref frequency
            ref_frequency_hz = frequency_coherence[frequency_coherence_max_index]
            ref_frequency_coherence = coherence_welch[frequency_ref_index]
            ref_frequency_response_magnitude_bits = 0.5*utils.log2epsilon(magnitude_norm[frequency_ref_index])
            ref_frequency_response_phase_degrees = phase_degrees[frequency_ref_index]

            # Return max coherence values
            max_coherence_frequency_hz = frequency_coherence[frequency_coherence_max_index]
            max_coherence = np.max(coherence_welch)
            max_coherence_response_magnitude_bits = 0.5*utils.log2epsilon(magnitude_norm[frequency_coherence_max_index])
            max_coherence_response_phase_degrees = phase_degrees[frequency_coherence_max_index]

            if n == m:
                max_coherence_frequency_hz = np.nan

            if &#39;max_coherence&#39; == export_option:
                coherence_frequency.append(max_coherence_frequency_hz)
                coherence_value.append(max_coherence)
                coherence_response_magnitude_bits.append(max_coherence_response_magnitude_bits)
                coherence_response_phase_degrees.append(max_coherence_response_phase_degrees)
            if &#39;ref_frequency&#39; == export_option:
                coherence_frequency.append(ref_frequency_hz)
                coherence_value.append(ref_frequency_coherence)
                coherence_response_magnitude_bits.append(ref_frequency_response_magnitude_bits)
                coherence_response_phase_degrees.append(ref_frequency_response_phase_degrees)

            if plot_response:
                rpd_plt.plot_psd_coh(psd_sig=psd_sig_bits, psd_ref=psd_ref_bits,
                                     coherence_sig_ref=coherence_welch,
                                     f_hz=frequency_coherence,
                                     f_min_hz=frequency_min_hz,
                                     f_max_hz=frequency_max_hz,
                                     f_scale=&#39;linear&#39;)

                rpd_plt.plot_psd_coh(psd_sig=cross_spectrum_bits, psd_ref=psd_ref_bits,
                                     coherence_sig_ref=coherence_welch,
                                     f_hz=frequency_coherence,
                                     f_min_hz=frequency_min_hz,
                                     f_max_hz=frequency_max_hz,
                                     f_scale=&#39;linear&#39;,
                                     sig_label=&#39;Cross spectrum&#39;)

                rpd_plt.plot_response_scatter(h_magnitude=magnitude_norm,
                                              h_phase_deg=phase_degrees,
                                              color_guide=coherence_welch,
                                              f_hz=frequency_coherence,
                                              f_min_hz=frequency_min_hz,
                                              f_max_hz=frequency_max_hz,
                                              f_scale=&#39;linear&#39;)

        df[new_column_label_cohere_frequency] = coherence_frequency
        df[new_column_label_cohere_value] = coherence_value
        df[new_column_label_cohere_response_magnitude_bits] = coherence_response_magnitude_bits
        df[new_column_label_cohere_response_phase_degrees] = coherence_response_phase_degrees

    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redpandas" href="index.html">redpandas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redpandas.redpd_cohere.coherence_numpy" href="#redpandas.redpd_cohere.coherence_numpy">coherence_numpy</a></code></li>
<li><code><a title="redpandas.redpd_cohere.coherence_re_ref_pandas" href="#redpandas.redpd_cohere.coherence_re_ref_pandas">coherence_re_ref_pandas</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>