<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redpandas.redpd_orientation API documentation</title>
<meta name="description" content="This module contains functions to integrate, and apply complimentary filters for phone orientation." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redpandas.redpd_orientation</code></h1>
</header>
<section id="section-intro">
This module contains functions to integrate, and apply complimentary filters for phone orientation.
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains functions to integrate, and apply complimentary filters for phone orientation.
&#34;&#34;&#34;

import numpy as np
from scipy.integrate import cumulative_trapezoid
from typing import List, Tuple


def remove_dc_offset(sensor_wf: np.ndarray, start_loc: int = None, end_loc: int = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    removes &#34;DC offset&#34; from the data by subtracting the mean of the specified subsection of the data.
    If start and end location is None, it uses the whole array, if one is given it will take the other to the max.

    :param sensor_wf: data to remove the &#34;DC offset&#34;
    :param start_loc: location of the start of the DC offset subset
    :param end_loc: location of the end of the DC offset subset
    :return: data with DC offset removed
    &#34;&#34;&#34;
    if start_loc and end_loc is None:
        removed = sensor_wf - np.nanmean(sensor_wf)
    elif start_loc is None:
        removed = sensor_wf - np.nanmean(sensor_wf[:end_loc])
    elif end_loc is None:
        removed = sensor_wf - np.nanmean(sensor_wf[start_loc:])
    else:
        removed = sensor_wf - np.nanmean(sensor_wf[start_loc:end_loc])
    return removed


def remove_dc_offset_s(timestamps_s: np.ndarray, sensor_wf: np.ndarray,
                       start_s: int = None, end_s: int = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    removes &#34;DC offset&#34; from the data by subtracting the mean of the specified subsection of the data.
    If start and end time is None, it uses the whole array, if one is given it will take the other to the max.

    :param timestamps_s: timestamps corresponding to the data in seconds
    :param sensor_wf: data to remove the &#34;DC offset&#34;
    :param start_s: seconds from the first timestamp to use as the start of the range for the DC offset subset
    :param end_s: seconds from the first timestamp to use as the end of the range for the DC offset subset
    :return: data with DC offset removed
    &#34;&#34;&#34;
    # adjust timestamps to be relative from the start
    timestamps_s_adj = timestamps_s - timestamps_s[0]

    # find location closest to the given start and end
    if start_s and end_s is None:
        start_loc = None
        end_loc = None
    elif start_s is None:
        start_loc = None
        end_loc = np.abs(timestamps_s_adj - end_s).argmin()
    elif end_s is None:
        start_loc = np.abs(timestamps_s_adj - start_s).argmin()
        end_loc = None
    else:
        start_loc = np.abs(timestamps_s_adj - start_s).argmin()
        end_loc = np.abs(timestamps_s_adj - end_s).argmin()

    # use remove_dc_offset to find the offset
    return remove_dc_offset(sensor_wf=sensor_wf, start_loc=start_loc, end_loc=end_loc)


def integrate_cumtrapz(timestamps_s: np.ndarray, sensor_wf: np.ndarray, initial_value: float = 0) -&gt; np.ndarray:
    &#34;&#34;&#34;
    cumulative trapazoid integration using scipy.integrate.cumulative_trapezoid

    :param timestamps_s: timestamps corresponding to the data in seconds
    :param sensor_wf: data to integrate using cumulative trapezoid
    :param initial_value: the value to add in the initial of the integrated data to match length of input (default is 0)
    :return: integrated data with the same length as the input
    &#34;&#34;&#34;

    integrated_data = cumulative_trapezoid(x=timestamps_s,
                                           y=sensor_wf,
                                           initial=initial_value)

    return integrated_data


def get_roll_pitch(accel_x: float, accel_y: float, accel_z: float) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Returns the pitch (rotation around y axis) and roll (rotation around x axis) from accelerometer data
    http://www.geekmomprojects.com/gyroscopes-and-accelerometers-on-a-chip/

    :param accel_x: x-axis acceleration value
    :param accel_y: y-axis acceleration value
    :param accel_z: z-axis acceleration value
    :return: pitch, roll
    &#34;&#34;&#34;
    # get angle in radians
    roll = np.arctan2(accel_y, np.sqrt(accel_x * accel_x + accel_z * accel_z))
    pitch = np.arctan2(-accel_x, np.sqrt(accel_y * accel_y + accel_z * accel_z))

    # convert to degrees
    return roll, pitch


def get_yaw(roll: float, pitch: float, mag_x: float, mag_y: float, mag_z: float) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns yaw based on roll / pitch data and the magnetometer data
    https://roboticsclubiitk.github.io/2017/12/21/Beginners-Guide-to-IMU.html

    :param roll: rotation around the x-axis
    :param pitch: rotation around the y-axis
    :param mag_x: x-axis magnetometer value
    :param mag_y: y-axis magnetometer value
    :param mag_z: z-axis magnetometer value
    :return: yaw
    &#34;&#34;&#34;
    mag_x_adj = mag_x*np.cos(pitch) + mag_y*np.sin(roll)*np.sin(pitch) + mag_z*np.cos(roll)*np.sin(pitch)
    mag_y_adj = mag_y * np.cos(roll) - mag_z*np.sin(roll)

    return np.arctan2(-mag_y_adj, mag_x_adj)


def get_roll_pitch_array(accelerometers: List) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;
    Returns the pitch (rotation around y axis) and roll (rotation around x axis) array from accelerometer data
    Loops through the get_pitch_and_roll function

    :param accelerometers: List of the xyz components of accelerometer data
    :return: pitch_array, roll_array
    &#34;&#34;&#34;
    # Loop through get_xy_rotation
    roll_array = []
    pitch_array = []

    for i in range(len(accelerometers[0])):
        pitch, roll = get_roll_pitch(accel_x=accelerometers[0][i],
                                     accel_y=accelerometers[1][i],
                                     accel_z=accelerometers[2][i])

        roll_array.append(roll)
        pitch_array.append(pitch)

    return np.array(roll_array), np.array(pitch_array)


def get_yaw_array(roll_array: np.ndarray, pitch_array: np.ndarray, magnetometers: List) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns the yaw array from roll (rotation around x axis), pitch (rotation around y axis), and gyroscope data

    :param roll_array: roll (rotation around x axis) calculated from sensors
    :param pitch_array: pitch (rotation around y axis) calculated from sensors
    :param magnetometers: List of xyz components of magnetometer data
    :return: yaw_array
    &#34;&#34;&#34;
    # Loop through get_xy_rotation
    yaw_array = []

    for i in range(len(magnetometers[0])):
        yaw = get_yaw(roll=roll_array[i],
                      pitch=pitch_array[i],
                      mag_x=magnetometers[0][i],
                      mag_y=magnetometers[1][i],
                      mag_z=magnetometers[2][i])

        yaw_array.append(yaw)

    return np.array(yaw_array)


def complimentary_filtering(gyroscope_time_s: np.ndarray, gyroscope_angle: np.ndarray,
                            accelerometer_angle: np.ndarray, smoothing_factor: float) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Complimentary Filter for Accelereometer and Gyroscope.
    Returns filtered angle
    Based on the works from https://stackoverflow.com/questions/1586658/combine-gyroscope-and-accelerometer-data and
    http://blog.bitify.co.uk/2013/11/using-complementary-filter-to-combine.html

    :param gyroscope_time_s: timestamps corresponding to the gyroscope data in seconds
    :param gyroscope_angle: the calculated angle from the gyroscope (roll, pitch, yaw)
    :param accelerometer_angle: the calculated angle from the accelerometer (roll, pitch, yaw)
    :param smoothing_factor: determines the sensitivity of the accelerometer
    :return: filtered angle
    &#34;&#34;&#34;
    # Get the change in gyroscope angle initiate with zero
    gyroscope_angle_change = np.diff(gyroscope_angle)
    gyroscope_time_delta = np.diff(gyroscope_time_s)

    # Loop through the data to apply complimentary filter
    filtered_angle = gyroscope_angle
    for i in range(len(accelerometer_angle) - 1):
        filtered_angle[i + 1] = \
            smoothing_factor * (filtered_angle[i] + gyroscope_angle_change[i] * gyroscope_time_delta[i]) \
            + smoothing_factor * accelerometer_angle[i + 1]

    return filtered_angle</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redpandas.redpd_orientation.complimentary_filtering"><code class="name flex">
<span>def <span class="ident">complimentary_filtering</span></span>(<span>gyroscope_time_s: numpy.ndarray, gyroscope_angle: numpy.ndarray, accelerometer_angle: numpy.ndarray, smoothing_factor: float) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc">Complimentary Filter for Accelereometer and Gyroscope.<br>Returns filtered angle<br>Based on the works from https://stackoverflow.com/questions/1586658/combine-gyroscope-and-accelerometer-data and<br>http://blog.bitify.co.uk/2013/11/using-complementary-filter-to-combine.html<br><br>:param gyroscope_time_s: timestamps corresponding to the gyroscope data in seconds<br>:param gyroscope_angle: the calculated angle from the gyroscope (roll, pitch, yaw)<br>:param accelerometer_angle: the calculated angle from the accelerometer (roll, pitch, yaw)<br>:param smoothing_factor: determines the sensitivity of the accelerometer<br>:return: filtered angle</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complimentary_filtering(gyroscope_time_s: np.ndarray, gyroscope_angle: np.ndarray,
                            accelerometer_angle: np.ndarray, smoothing_factor: float) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Complimentary Filter for Accelereometer and Gyroscope.
    Returns filtered angle
    Based on the works from https://stackoverflow.com/questions/1586658/combine-gyroscope-and-accelerometer-data and
    http://blog.bitify.co.uk/2013/11/using-complementary-filter-to-combine.html

    :param gyroscope_time_s: timestamps corresponding to the gyroscope data in seconds
    :param gyroscope_angle: the calculated angle from the gyroscope (roll, pitch, yaw)
    :param accelerometer_angle: the calculated angle from the accelerometer (roll, pitch, yaw)
    :param smoothing_factor: determines the sensitivity of the accelerometer
    :return: filtered angle
    &#34;&#34;&#34;
    # Get the change in gyroscope angle initiate with zero
    gyroscope_angle_change = np.diff(gyroscope_angle)
    gyroscope_time_delta = np.diff(gyroscope_time_s)

    # Loop through the data to apply complimentary filter
    filtered_angle = gyroscope_angle
    for i in range(len(accelerometer_angle) - 1):
        filtered_angle[i + 1] = \
            smoothing_factor * (filtered_angle[i] + gyroscope_angle_change[i] * gyroscope_time_delta[i]) \
            + smoothing_factor * accelerometer_angle[i + 1]

    return filtered_angle</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_orientation.get_roll_pitch"><code class="name flex">
<span>def <span class="ident">get_roll_pitch</span></span>(<span>accel_x: float, accel_y: float, accel_z: float) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc">Returns the pitch (rotation around y axis) and roll (rotation around x axis) from accelerometer data<br>http://www.geekmomprojects.com/gyroscopes-and-accelerometers-on-a-chip/<br><br>:param accel_x: x-axis acceleration value<br>:param accel_y: y-axis acceleration value<br>:param accel_z: z-axis acceleration value<br>:return: pitch, roll</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_roll_pitch(accel_x: float, accel_y: float, accel_z: float) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Returns the pitch (rotation around y axis) and roll (rotation around x axis) from accelerometer data
    http://www.geekmomprojects.com/gyroscopes-and-accelerometers-on-a-chip/

    :param accel_x: x-axis acceleration value
    :param accel_y: y-axis acceleration value
    :param accel_z: z-axis acceleration value
    :return: pitch, roll
    &#34;&#34;&#34;
    # get angle in radians
    roll = np.arctan2(accel_y, np.sqrt(accel_x * accel_x + accel_z * accel_z))
    pitch = np.arctan2(-accel_x, np.sqrt(accel_y * accel_y + accel_z * accel_z))

    # convert to degrees
    return roll, pitch</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_orientation.get_roll_pitch_array"><code class="name flex">
<span>def <span class="ident">get_roll_pitch_array</span></span>(<span>accelerometers: List) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc">Returns the pitch (rotation around y axis) and roll (rotation around x axis) array from accelerometer data<br>Loops through the get_pitch_and_roll function<br><br>:param accelerometers: List of the xyz components of accelerometer data<br>:return: pitch_array, roll_array</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_roll_pitch_array(accelerometers: List) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;
    Returns the pitch (rotation around y axis) and roll (rotation around x axis) array from accelerometer data
    Loops through the get_pitch_and_roll function

    :param accelerometers: List of the xyz components of accelerometer data
    :return: pitch_array, roll_array
    &#34;&#34;&#34;
    # Loop through get_xy_rotation
    roll_array = []
    pitch_array = []

    for i in range(len(accelerometers[0])):
        pitch, roll = get_roll_pitch(accel_x=accelerometers[0][i],
                                     accel_y=accelerometers[1][i],
                                     accel_z=accelerometers[2][i])

        roll_array.append(roll)
        pitch_array.append(pitch)

    return np.array(roll_array), np.array(pitch_array)</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_orientation.get_yaw"><code class="name flex">
<span>def <span class="ident">get_yaw</span></span>(<span>roll: float, pitch: float, mag_x: float, mag_y: float, mag_z: float) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc">Returns yaw based on roll / pitch data and the magnetometer data<br>https://roboticsclubiitk.github.io/2017/12/21/Beginners-Guide-to-IMU.html<br><br>:param roll: rotation around the x-axis<br>:param pitch: rotation around the y-axis<br>:param mag_x: x-axis magnetometer value<br>:param mag_y: y-axis magnetometer value<br>:param mag_z: z-axis magnetometer value<br>:return: yaw</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_yaw(roll: float, pitch: float, mag_x: float, mag_y: float, mag_z: float) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns yaw based on roll / pitch data and the magnetometer data
    https://roboticsclubiitk.github.io/2017/12/21/Beginners-Guide-to-IMU.html

    :param roll: rotation around the x-axis
    :param pitch: rotation around the y-axis
    :param mag_x: x-axis magnetometer value
    :param mag_y: y-axis magnetometer value
    :param mag_z: z-axis magnetometer value
    :return: yaw
    &#34;&#34;&#34;
    mag_x_adj = mag_x*np.cos(pitch) + mag_y*np.sin(roll)*np.sin(pitch) + mag_z*np.cos(roll)*np.sin(pitch)
    mag_y_adj = mag_y * np.cos(roll) - mag_z*np.sin(roll)

    return np.arctan2(-mag_y_adj, mag_x_adj)</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_orientation.get_yaw_array"><code class="name flex">
<span>def <span class="ident">get_yaw_array</span></span>(<span>roll_array: numpy.ndarray, pitch_array: numpy.ndarray, magnetometers: List) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc">Returns the yaw array from roll (rotation around x axis), pitch (rotation around y axis), and gyroscope data<br><br>:param roll_array: roll (rotation around x axis) calculated from sensors<br>:param pitch_array: pitch (rotation around y axis) calculated from sensors<br>:param magnetometers: List of xyz components of magnetometer data<br>:return: yaw_array</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_yaw_array(roll_array: np.ndarray, pitch_array: np.ndarray, magnetometers: List) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns the yaw array from roll (rotation around x axis), pitch (rotation around y axis), and gyroscope data

    :param roll_array: roll (rotation around x axis) calculated from sensors
    :param pitch_array: pitch (rotation around y axis) calculated from sensors
    :param magnetometers: List of xyz components of magnetometer data
    :return: yaw_array
    &#34;&#34;&#34;
    # Loop through get_xy_rotation
    yaw_array = []

    for i in range(len(magnetometers[0])):
        yaw = get_yaw(roll=roll_array[i],
                      pitch=pitch_array[i],
                      mag_x=magnetometers[0][i],
                      mag_y=magnetometers[1][i],
                      mag_z=magnetometers[2][i])

        yaw_array.append(yaw)

    return np.array(yaw_array)</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_orientation.integrate_cumtrapz"><code class="name flex">
<span>def <span class="ident">integrate_cumtrapz</span></span>(<span>timestamps_s: numpy.ndarray, sensor_wf: numpy.ndarray, initial_value: float = 0) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc">cumulative trapazoid integration using scipy.integrate.cumulative_trapezoid<br><br>:param timestamps_s: timestamps corresponding to the data in seconds<br>:param sensor_wf: data to integrate using cumulative trapezoid<br>:param initial_value: the value to add in the initial of the integrated data to match length of input (default is 0)<br>:return: integrated data with the same length as the input</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate_cumtrapz(timestamps_s: np.ndarray, sensor_wf: np.ndarray, initial_value: float = 0) -&gt; np.ndarray:
    &#34;&#34;&#34;
    cumulative trapazoid integration using scipy.integrate.cumulative_trapezoid

    :param timestamps_s: timestamps corresponding to the data in seconds
    :param sensor_wf: data to integrate using cumulative trapezoid
    :param initial_value: the value to add in the initial of the integrated data to match length of input (default is 0)
    :return: integrated data with the same length as the input
    &#34;&#34;&#34;

    integrated_data = cumulative_trapezoid(x=timestamps_s,
                                           y=sensor_wf,
                                           initial=initial_value)

    return integrated_data</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_orientation.remove_dc_offset"><code class="name flex">
<span>def <span class="ident">remove_dc_offset</span></span>(<span>sensor_wf: numpy.ndarray, start_loc: int = None, end_loc: int = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc">removes "DC offset" from the data by subtracting the mean of the specified subsection of the data.<br>If start and end location is None, it uses the whole array, if one is given it will take the other to the max.<br><br>:param sensor_wf: data to remove the "DC offset"<br>:param start_loc: location of the start of the DC offset subset<br>:param end_loc: location of the end of the DC offset subset<br>:return: data with DC offset removed</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_dc_offset(sensor_wf: np.ndarray, start_loc: int = None, end_loc: int = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    removes &#34;DC offset&#34; from the data by subtracting the mean of the specified subsection of the data.
    If start and end location is None, it uses the whole array, if one is given it will take the other to the max.

    :param sensor_wf: data to remove the &#34;DC offset&#34;
    :param start_loc: location of the start of the DC offset subset
    :param end_loc: location of the end of the DC offset subset
    :return: data with DC offset removed
    &#34;&#34;&#34;
    if start_loc and end_loc is None:
        removed = sensor_wf - np.nanmean(sensor_wf)
    elif start_loc is None:
        removed = sensor_wf - np.nanmean(sensor_wf[:end_loc])
    elif end_loc is None:
        removed = sensor_wf - np.nanmean(sensor_wf[start_loc:])
    else:
        removed = sensor_wf - np.nanmean(sensor_wf[start_loc:end_loc])
    return removed</code></pre>
</details>
</dd>
<dt id="redpandas.redpd_orientation.remove_dc_offset_s"><code class="name flex">
<span>def <span class="ident">remove_dc_offset_s</span></span>(<span>timestamps_s: numpy.ndarray, sensor_wf: numpy.ndarray, start_s: int = None, end_s: int = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc">removes "DC offset" from the data by subtracting the mean of the specified subsection of the data.<br>If start and end time is None, it uses the whole array, if one is given it will take the other to the max.<br><br>:param timestamps_s: timestamps corresponding to the data in seconds<br>:param sensor_wf: data to remove the "DC offset"<br>:param start_s: seconds from the first timestamp to use as the start of the range for the DC offset subset<br>:param end_s: seconds from the first timestamp to use as the end of the range for the DC offset subset<br>:return: data with DC offset removed</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_dc_offset_s(timestamps_s: np.ndarray, sensor_wf: np.ndarray,
                       start_s: int = None, end_s: int = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    removes &#34;DC offset&#34; from the data by subtracting the mean of the specified subsection of the data.
    If start and end time is None, it uses the whole array, if one is given it will take the other to the max.

    :param timestamps_s: timestamps corresponding to the data in seconds
    :param sensor_wf: data to remove the &#34;DC offset&#34;
    :param start_s: seconds from the first timestamp to use as the start of the range for the DC offset subset
    :param end_s: seconds from the first timestamp to use as the end of the range for the DC offset subset
    :return: data with DC offset removed
    &#34;&#34;&#34;
    # adjust timestamps to be relative from the start
    timestamps_s_adj = timestamps_s - timestamps_s[0]

    # find location closest to the given start and end
    if start_s and end_s is None:
        start_loc = None
        end_loc = None
    elif start_s is None:
        start_loc = None
        end_loc = np.abs(timestamps_s_adj - end_s).argmin()
    elif end_s is None:
        start_loc = np.abs(timestamps_s_adj - start_s).argmin()
        end_loc = None
    else:
        start_loc = np.abs(timestamps_s_adj - start_s).argmin()
        end_loc = np.abs(timestamps_s_adj - end_s).argmin()

    # use remove_dc_offset to find the offset
    return remove_dc_offset(sensor_wf=sensor_wf, start_loc=start_loc, end_loc=end_loc)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redpandas" href="index.html">redpandas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redpandas.redpd_orientation.complimentary_filtering" href="#redpandas.redpd_orientation.complimentary_filtering">complimentary_filtering</a></code></li>
<li><code><a title="redpandas.redpd_orientation.get_roll_pitch" href="#redpandas.redpd_orientation.get_roll_pitch">get_roll_pitch</a></code></li>
<li><code><a title="redpandas.redpd_orientation.get_roll_pitch_array" href="#redpandas.redpd_orientation.get_roll_pitch_array">get_roll_pitch_array</a></code></li>
<li><code><a title="redpandas.redpd_orientation.get_yaw" href="#redpandas.redpd_orientation.get_yaw">get_yaw</a></code></li>
<li><code><a title="redpandas.redpd_orientation.get_yaw_array" href="#redpandas.redpd_orientation.get_yaw_array">get_yaw_array</a></code></li>
<li><code><a title="redpandas.redpd_orientation.integrate_cumtrapz" href="#redpandas.redpd_orientation.integrate_cumtrapz">integrate_cumtrapz</a></code></li>
<li><code><a title="redpandas.redpd_orientation.remove_dc_offset" href="#redpandas.redpd_orientation.remove_dc_offset">remove_dc_offset</a></code></li>
<li><code><a title="redpandas.redpd_orientation.remove_dc_offset_s" href="#redpandas.redpd_orientation.remove_dc_offset_s">remove_dc_offset_s</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>